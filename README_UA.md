# txtfmt

`txtfmt` — CLI-утиліта на Go для детермінованого форматування тексту (RU/UA/EN), орієнтована на художні та технічні тексти.

Вона читає вхідний текст із файла або `stdin`, нормалізує типографіку та виводить перезаписаний текст у `stdout`.

## Що вміє

- Нормалізує тире, пробіли та трикрапку.
- Нормалізує лапки з урахуванням вкладеності.
- Розпізнає діалогові рядки та нормалізує маркер репліки до `—`.
- За `-lang auto` (типово) автоматично визначає мову вхідного тексту (`en`/`ru`/`ua`).
- Підтримує розділювачі сцен (`***`, `-----`, `x x x` та подібні варіанти).
- Розпізнає блоки змісту (`CONTENTS` / `СОДЕРЖАНИЕ` / `ЗМІСТ`) із вкладеними записами розділів.
- Розпізнає метадані у форматі `Key: value` як окремі блоки.
- Пише diagnostics у `stderr` без змішування з форматованим виводом.
- Підтримує UTF-8 і legacy-кодування (наприклад, `cp1251`, `koi8-r`).
- Може вивести розпарсене AST у JSON для відлагодження (`-dump-ast`).

## Вимоги

- Go `1.24+`

## Збирання

```bash
go build -o txtfmt ./cmd/txtfmt
```

Або запуск без збирання:

```bash
go run ./cmd/txtfmt -input <file-or-stdin>
```

## Використання

```bash
txtfmt -input <file|-> [options]
```

Важливо:

- `-input` є обов'язковим.
- Позиційні аргументи не підтримуються.
- Якщо `-input` не задано, програма виводить help у `stderr` і завершується без форматування.

## Прапорці

- `-input <file|->`
  Джерело вхідних даних: шлях до файла або `-` для `stdin`.
- `-output <file|->`
  Призначення виводу: шлях до файла або `-` для `stdout`.
  Якщо не задано, вивід іде в `stdout`.
- `-format plain|markdown|html|xml`
  Формат вихідного тексту (типово: `plain`).
- `-lang auto|en|ru|ua`  
  Мовні правила (типово: `auto`).  
  Якщо встановлено `auto`, мова визначається за вхідним текстом; якщо визначення невпевнене, використовується fallback `en`.
- `-inner-quotes german|english|guillemets`
  Стиль внутрішніх лапок (перевизначає лише вкладену пару лапок).
- `-nbsp`
  Увімкнути перетворення нерозривних пробілів (NBSP).
- `-dump-ast`
  Вивести AST JSON у `stderr` (до етапу rewrite).
- `-input-charset <name>`
  Кодування вхідного тексту (типово: `utf-8`).
- `-output-charset <name>`
  Кодування вихідного тексту (типово: `utf-8`).

## Коди завершення

- `0` форматування завершено успішно (навіть якщо є diagnostics).
- `1` помилка читання/запису/декодування/внутрішня помилка.
- `2` некоректні CLI-аргументи або значення прапорців.

## Швидкі приклади

Форматування файла:

```bash
./txtfmt -input input.txt > output.txt
```

Форматування безпосередньо у вихідний файл:

```bash
./txtfmt -input input.txt -output output.txt
```

Форматування з `stdin`:

```bash
echo '- Привет!' | ./txtfmt -lang ru -input -
```

Генерація Markdown:

```bash
./txtfmt -input input.txt -format markdown
```

Генерація HTML:

```bash
./txtfmt -input input.txt -format html
```

Генерація XML:

```bash
./txtfmt -input input.txt -format xml
```

Читати `cp1251`, писати UTF-8:

```bash
./txtfmt -input book.txt -input-charset cp1251 -output-charset utf-8 > book.utf8.txt
```

Читати/писати `cp1251`:

```bash
./txtfmt -input in.txt -input-charset cp1251 -output-charset cp1251 > out.txt
```

Вивести AST + форматований текст:

```bash
./txtfmt -input in.txt -dump-ast > out.txt 2> debug.log
```

## Потоки виводу

- `stdout`: форматований текст (якщо не використано `-output <file>`).
- `stderr`: diagnostics і (якщо увімкнено `-dump-ast`) AST JSON.

Формат diagnostics:

```text
line:col CODE message
```

Приклад:

```text
2328:89 PAREN_MISMATCH unexpected closing parenthesis
```

## Підтримувані кодування

`txtfmt` використовує `golang.org/x/text/encoding/charmap` і приймає стандартні назви/аліаси.

Поширені варіанти:

- `utf-8`
- `cp1251` (`windows-1251`)
- `koi8-r`
- `koi8-u`
- `cp866`
- `iso-8859-5`
- `mac-cyrillic`

Якщо кодування не підтримується, помилка виглядає так:

```text
unsupported charset "<name>" (examples: utf-8, cp1251, koi8-r, ...)
```

## Правила форматування (коротко)

- `...` -> `…`
- `word-word` (без пробілів) залишається дефісом `-`
- `1990-2000` (без пробілів) -> en dash `–`
- Інші варіанти тире нормалізуються до em dash `—` з правильними пробілами
- Лапки виводяться канонічними парами залежно від мови та рівня вкладеності
- Маркери діалогів нормалізуються до `—` з одним пробілом після нього
- За `-nbsp` застосовуються правила NBSP для коротких службових слів RU/UA, ініціалів і патернів на кшталт `№ 12`, `стр. 5`

## Поведінка block-парсера

- Підтримуються:
  - звичайні абзаци,
  - діалогові блоки (рядки, що починаються з `- ` або `— `),
  - заголовки (`# Heading` і книжкові форми на кшталт `Глава ...`, `Часть ...`, `Chapter ...`, `Розділ ...`),
  - окремі блоки змісту з вкладеними записами розділів,
  - мета-рядки (`Key: value`) як окремі блоки,
  - розділювачі сцен.
- Сусідні діалогові рядки групуються в один `DialogueBlock`.
- Якщо діалогові рядки розділені авторським текстом, це будуть окремі блоки.
- Для OCR/книжкових переносів рядків застосовуються евристики, щоб не зливати цілий розділ в один абзац.

## Обмеження

- Немає NLP/ML, лише локальні детерміновані евристики.
- Підтримка Markdown у вхідному тексті обмежена (переважно `#`-заголовки та базова текстова структура).
- У неоднозначних OCR-випадках симетричні лапки можуть залишатися literal, щоб уникнути шумних хибнопозитивних попереджень.

## Тестування

```bash
go test ./...
```
