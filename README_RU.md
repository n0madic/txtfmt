# txtfmt

`txtfmt` — CLI-утилита на Go для детерминированного форматирования художественного и технического текста (RU/UA/EN).

Инструмент читает текст из файла или `stdin`, нормализует типографику и выводит переписанный результат в `stdout`.

## Что умеет

- Нормализует тире, пробелы и многоточия.
- Нормализует кавычки с учетом вложенности.
- Распознает диалоги и приводит маркер реплики к `—`.
- При `-lang auto` (по умолчанию) определяет язык входа автоматически (`en`/`ru`/`ua`).
- Поддерживает scene breaks (`***`, `-----`, `x x x` и похожие варианты).
- Распознает блоки содержания (`СОДЕРЖАНИЕ` / `CONTENTS` / `ЗМІСТ`) и вложенный список глав.
- Распознает мета-строки формата `Ключ: значение` как отдельные блоки.
- Пишет диагностику в `stderr` без смешивания с основным выводом.
- Поддерживает вход/выход в UTF-8 и legacy-кодировках (например `cp1251`, `koi8-r`).
- Может вывести отпарсенное AST-дерево для отладки (`-dump-ast`).

## Требования

- Go `1.24+`

## Сборка

```bash
go build -o txtfmt ./cmd/txtfmt
```

Либо запуск без сборки:

```bash
go run ./cmd/txtfmt -input <file-or-stdin>
```

## Использование

```bash
txtfmt -input <file|-> [options]
```

Важно:

- Флаг `-input` обязателен.
- Позиционные аргументы не поддерживаются.
- Если `-input` не указан, программа печатает help в `stderr` и завершает работу без форматирования.

## Флаги

- `-input <file|->`  
  Источник входа: путь к файлу или `-` для `stdin`.
- `-output <file|->`  
  Куда писать результат: путь к файлу или `-` для `stdout`.  
  Если не задан, результат пишется в `stdout`.
- `-format plain|markdown|html|xml`  
  Формат выходного текста (по умолчанию: `plain`).
- `-lang auto|en|ru|ua`  
  Язык правил (по умолчанию: `auto`).  
  Если задано `auto`, язык определяется автоматически по входному тексту; при неуверенном детекте используется fallback `en`.
- `-inner-quotes german|english|guillemets`  
  Стиль внутренних кавычек (переопределяет только вложенный уровень).
- `-nbsp`  
  Включить правила неразрывных пробелов (NBSP).
- `-dump-ast`  
  Вывести AST в JSON в `stderr` (до rewrite-этапа).
- `-input-charset <name>`  
  Кодировка входа (по умолчанию: `utf-8`).
- `-output-charset <name>`  
  Кодировка выхода (по умолчанию: `utf-8`).

## Коды завершения

- `0` — успешное форматирование (даже если были warnings в diagnostics).
- `1` — ошибка чтения/записи/декодирования/внутренняя ошибка.
- `2` — ошибка аргументов или значений флагов.

## Быстрые примеры

Форматирование файла:

```bash
./txtfmt -input input.txt > output.txt
```

Форматирование сразу в выходной файл:

```bash
./txtfmt -input input.txt -output output.txt
```

Форматирование из `stdin`:

```bash
echo '- Привет!' | ./txtfmt -lang ru -input -
```

Генерация Markdown:

```bash
./txtfmt -input input.txt -format markdown
```

Генерация HTML:

```bash
./txtfmt -input input.txt -format html
```

Генерация XML:

```bash
./txtfmt -input input.txt -format xml
```

Вход в `cp1251`, выход в UTF-8:

```bash
./txtfmt -input book.txt -input-charset cp1251 -output-charset utf-8 > book.utf8.txt
```

Вход/выход в `cp1251`:

```bash
./txtfmt -input in.txt -input-charset cp1251 -output-charset cp1251 > out.txt
```

Отладка AST + форматирование:

```bash
./txtfmt -input in.txt -dump-ast > out.txt 2> debug.log
```

## Потоки вывода

- `stdout`: только переписанный текст (если не задан `-output <file>`).
- `stderr`: diagnostics и (если включен `-dump-ast`) JSON AST.

Формат diagnostics:

```text
line:col CODE message
```

Пример:

```text
2328:89 PAREN_MISMATCH unexpected closing parenthesis
```

## Поддерживаемые кодировки

`txtfmt` использует `golang.org/x/text/encoding/charmap` и принимает стандартные имена/алиасы.

Частые варианты:

- `utf-8`
- `cp1251` (`windows-1251`)
- `koi8-r`
- `koi8-u`
- `cp866`
- `iso-8859-5`
- `mac-cyrillic`

Если кодировка не поддерживается, будет ошибка вида:

```text
unsupported charset "<name>" (examples: utf-8, cp1251, koi8-r, ...)
```

## Правила форматирования (кратко)

- `...` → `…`
- `word-word` (без пробелов) остается дефисом `-`
- `1990-2000` (без пробелов) → en-dash `–`
- Прочие тире в тексте нормализуются к em-dash `—` с корректными пробелами
- Кавычки приводятся к каноническим парам по языку и глубине вложенности
- Для диалогов маркер реплики нормализуется к `—` и одному пробелу после него
- При `-nbsp` применяются правила NBSP для коротких служебных слов RU/UA, инициалов и паттернов вида `№ 12`, `стр. 5`

## Что важно знать про парсер блоков

- Поддерживаются:
  - обычные абзацы,
  - диалоговые блоки (строки, начинающиеся с `- ` или `— `),
  - heading (`# Заголовок`, а также книжные формы вроде `Глава ...`, `Часть ...`, `Chapter ...`, `Розділ ...`),
  - отдельные блоки содержания с вложенными записями глав,
  - мета-строки (`Ключ: значение`) как отдельные блоки,
  - scene breaks.
- Соседние диалоговые строки объединяются в один `DialogueBlock`.
- Если между диалогами есть обычный текст, это уже разные блоки.
- Для OCR/книжной верстки с переносами строк применяются эвристики, чтобы не схлопывать длинные главы в один абзац.

## Ограничения

- NLP/ML не используется: только локальные детерминированные эвристики.
- Поддержка Markdown во входном тексте ограничена (в основном `#`-заголовки и базовая текстовая структура).
- В спорных OCR-сценариях симметричные кавычки могут быть оставлены literal, чтобы не создавать лавину ложных warning.

## Тестирование

```bash
go test ./...
```
